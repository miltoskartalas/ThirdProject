 
Μιλτιάδης Καρταλάς
ΑΜ: 1115201800313

Σημείωση : Δεν εχω υλοποιήσει την travelStats και την addVaccinationRecords



Επεξήγηση του functions.cpp / functions.h

Στο αρχειο αυτο έχω τις επιπλεον συναρτήσεις που χρειάζονται εκτός αυτων των δομών μου ( π.χ λίστες ) και ενα struct το threadInfo 
στο οποιο κρατάω όλες τους δείκτες των δομών ώστε να τα δώσω στα threads.

Στην εργασία αυτή χρησιμοποιώ τις ίδιες δομές με τη πρώτη. Πλέον η main της πρώτης εργασίας όπου γινόταν η επεξεργασία
του αρχειου και αρχικοποιούσα τις δομές. Γίνεται στην συνάρτηση AddToFile.

Η createMonitors είναι η συνάρτηση που καλείται απο το travelMonitor και φτιάχνει τα monitors εκέι γίνεται και το 
round robin των directories που θα εχει το καθε monitor και κανω execvp με πίνακα char** ο οποιος περιέχει όλα τα ορίσματα
που παίρνουμε απο τον χρήστη συν τα paths που θα έχει το καθε monitor

H readBloomFiltersFromMonitor είναι συνάρτηση που καλεί ο travelMonitor ώστε να διαβάσει τα bloomFilters απο τα monitor
μολις αυτα τα έχουν έτοιμα

H readStringClient είναι η συνάρτηση που χρησιμοποιει ο client για να διαβασει string απο τον server 
για αυτο χρησιμοποιω τη λιστα με τους Fds . Αντίστοιχη λογική και η readIntClient

readStringServer / readIntServer είναι συναρτήσεις που διαβάζει ο server απο τον client string και int αντίστοιχα

Η createThreads είναι η συνάρτηση η οποία φτιάχνει τα threads, ως όρισμα παιρνει το πληθος των threads που θελω να φτιάξω
το struct το οποίο έχει τους δείκτες των δομών μου, και έναν πίνακα όπου κρατάω τα pthread_t. Αυτό τον κατασκευάζω έξω,
ώστε να τον έχω και στο τέλος του προγραμμάτος όταν θέλω να κάνω exit για να κάνω join τα threads

Η pathsInDirectories είναι συνάρτηση η οποία μετράει πόσα .txt έχουν τα directories των χωρών που έχει πάρει
το καθε monitor. Δηλαδή αν ενα monitor έχει το script/input_dir/Greece & script/input_dir/Italy τη χρησιμοποιώ για να ξέρω
πόσα txt θα έχω συνολικά και απο τα δύο.

Ακόμη έχω την συνάρτηση threadFunction η οποία είναι αυτη που περνιέται ως όρισμα στη pthread_create
Επεξήγηση του Buffe.cpp / Buffer.h

O buffer μου είναι struct και έχω τις συναρτήσεις initialize, place , obtain , getPathsRead & addPathRead

Η place συνάρτηση είναι αυτη η οποία που τοποθετεί στον buffer τα paths που θα πρεπει να παρουν τα threads, για να το πετυχω 
αυτο παντα στην αρχη κανω lock mutex  και μετα σε μια while περιμένω για όσο δεν χωράει. Οταν θα βγει απο εκει παω και ανανεώνω
τα μέλη του buffer.

Η οbtain είαι αυτη που ελεγχει και τη χρησιμοποιω για οταν θελω να παρω κατι. Όσο το count <=0 δεν υπάρχει κάτι για να πάρω
ότε δεν ισχυύει αυτο κανω unlock και επιστρέφω το μονοπάτι απο την αρχη του buffer.

Μετα εχω δυο συναρτήσεις την  getPathsRead και την addPathRead . Η πρώτη μου επιστρέφει ποσα έχει διαβάσει το thread και 
η δευτερη αυξάνει αυτον τον counter δηλαδη το πόσα έχει διαβάσει. 

* Σημείωση * την ιδεα του producer την υλοποιώ στο monitorServer.cpp στις γραμμες 140-150 δηλαδή εκει καλω τη place



ΔΙΑΔΙΚΑΣΙΑ ΔΙΑΒΑΣΜΑΤΟΣ - AΠΟΣΤΟΛΗΣ BLOOMFILTERS

Απο τη μεριά του monitorServer : 

Ξεκινάω παίρνοντας για κάθε ιο το bloomfilter. Έπειτα στελνω στο travelMonitor για ποιον ιο πρόκειται να λάβει bloomfilter
Μετά ξεκινάω και παίρνω τους ακεραίους του BloomArray. Επειδη ο πινακας είναι απο ακεραίους ξεκινάω και στέλνω πρώτα όσους
μπορώ να στείλω (σε περιπτωση δηλαδη που το buffersize μου δεν ειναι πολλαπλασιο του 4) και έπειτα στέλνω οσους περισσευόυν.

Απο τη μεριά του travelMonitorClient :

Ο client φτιαχνει μια λίστα τύπου BloomList η οποία κρατάει όλα τα BloomFilters που πρόκειται να λάβει απο τους servers
Έπειτα περιμένει απο τον server το ονομα του ιου για τον οποιο προκειται να λαβει το bloomfilter. Μόλις λάβει το όνομα
του ιου, αναζητώ μεσα στη λίστα τον bloomFilters αν έχω ήδη bloomFilter για αυτον τον ιο. Αν όχι φτιάχνω καινούργιο κόμβο για
τη λίστα. Μετά πάω και παίρνω σε εναν δείκτη το bloomArray, δηλαδη τον πίνακα απο ints που έχω και κάνω bitwise OR με κάθε
int που διαβάζω (το διαβασμα γινεται αντιστοιχα με την αποστολή)



Επεξήγηση Commands :

/travelRequest 

Οταν το monitorServer λαβει αυτή την εντολή. Περιμένει να διαβάσει τον ιο και το citizenId. Μόλις τα διαβάσει, ψάχνει
στη virusList να βρεί τον node αυτου του ιού για να μπορέσει να πάρει τις Skiplists. Απο τη πρωτη εργασια ειχα μια συναρτηση
η οποια παιρνει ως ορισμα true/false και μου επιστρεφει αντίστοιχα τις skiplists. Οπότε παιρνω για αρχη αυτη με τους εμβολιασμένους
αν δεν υπαρχει σημαινει πως δεν ειναι εμβολιασμενος, και για αυτο θα παρει αντίστοιχο μήνυμα. Σε περίπτωση που βρεθεί, 
στελνω YES στο travelMonitorClient ώστε να περιμένει να πάρει την ημερομηνια για το ποτε εμβολιάστηκε,τότε με βάση 
την ημερομηνια που πηρε ως input απο τον χρήστη να εκτυπώσει το αντίστοιχο μήνυμα.

/searchVaccinationStatus 

Όταν το monitorServer λάβει αυτη την εντολη,ξεκινάει για καθε ιο και ψαχνει την skiplist με τους εμβολιασμενους, αν βρει
επιστρεφει πισω τα παραπανω στοιχεια, αντιστοιχα κανει και για τη notVaccinatedSkiplist 



* Σημειωση * 
Ενα bug που εχω εντοπισει αλλα μεχρι τωρα δεν εχω καταφερει να διορθωσω ειναι οταν στειλω δευτερη φορα εντολη searchVaccinationStatus
να τρώω broken pipe. Απο τη γραμμη 231 του travelMonitorClient, στο σημειο που ξανα στελνω δηλαδη το command. Αυτο συμβαίνει
μονο για αυτη την εντολη, δηλαδη travelRequests όσα και να παρει δεν θα συμβει.

/exit
οταν λαβει exit, ο monitorServer κανει place στο buffer "END" για να καταλαβουν οτι πρεπει να κλεισουν έτσι στη συνάρτηση
obtain τσεκαρω αν το pathToGet ειναι το END , και τοτε τα κλείνω. O server μετα τα κανει join με το main thread, εκτυπωνει
τα logFiles και επειτα αποδεσμέυει τη μνήμη.

